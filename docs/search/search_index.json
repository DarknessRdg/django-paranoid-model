{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"django-paranoid-model \u00b6 Django abstract model with paranoid behavior, therefore when an instance is deleted it is not really deleted from database, it's applied a mask on the filter so when filter, the result are the \"undeleted\" instances. This package is useful when you want to keep all datas saved on your database and when user wants do delete, it is just hidden form user. It includes some helpers fields to your model: created_at updated_at deleted_at Quick start \u00b6 Install Django Paranoid Model package from pip 1 pip install django - paranoid - model Add paranoid_model to your installed apps so you can use django admin with a paranoid behavior 1 2 3 4 INSTALLED_APPS = [ ... 'paranoid_model' ] Good job ! You're now ready to use it.","title":"Home"},{"location":"#django-paranoid-model","text":"Django abstract model with paranoid behavior, therefore when an instance is deleted it is not really deleted from database, it's applied a mask on the filter so when filter, the result are the \"undeleted\" instances. This package is useful when you want to keep all datas saved on your database and when user wants do delete, it is just hidden form user. It includes some helpers fields to your model: created_at updated_at deleted_at","title":"django-paranoid-model"},{"location":"#quick-start","text":"Install Django Paranoid Model package from pip 1 pip install django - paranoid - model Add paranoid_model to your installed apps so you can use django admin with a paranoid behavior 1 2 3 4 INSTALLED_APPS = [ ... 'paranoid_model' ] Good job ! You're now ready to use it.","title":"Quick start"},{"location":"create_your_paranoid_model/","text":"Create your Paranoid Model \u00b6 On your models.py file import Paranoid class from paranoid_models.models file, then inheritance Paranoid class on your models 1 2 3 4 5 6 7 8 9 from django.db import models from paranoid_model.models import Paranoid class Person ( Paranoid ): # make an inheritance # all the default fields come with inheritance: # created_at # updated_at # deleted_at name = models . CharField ( max_length = 255 ) Note created_at : is the field with creation date updated_at : is the field with latest update date deleted_at : is the field with deletion date, so when it is None it means it hasn't been deleted","title":"Create your paranoid model"},{"location":"create_your_paranoid_model/#create-your-paranoid-model","text":"On your models.py file import Paranoid class from paranoid_models.models file, then inheritance Paranoid class on your models 1 2 3 4 5 6 7 8 9 from django.db import models from paranoid_model.models import Paranoid class Person ( Paranoid ): # make an inheritance # all the default fields come with inheritance: # created_at # updated_at # deleted_at name = models . CharField ( max_length = 255 ) Note created_at : is the field with creation date updated_at : is the field with latest update date deleted_at : is the field with deletion date, so when it is None it means it hasn't been deleted","title":"Create your Paranoid Model"},{"location":"django_admin/","text":"Django Admin \u00b6 Register your models \u00b6 To register your model on django admin, is recomended to let ParanoidAdmin handle with admin action. Otherwise you may have some trouble. ParanoidAdmin also include some aditional methods to look more \"paranoid\" on admin page, some functions are: Delete: soft delete instance Permanently delete: hard delete Restore: remode deleted_at date Filter: filter all, only deleted, not deleted On you admin.py register you models like the example below: 1 2 3 4 5 6 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel admin . site . register ( MyModel , ParanoidAdmin ) This will allow ParanoidAdmin to handle with admin actions. Once done that, it should looks something like this: Customize list \u00b6 You can customize the way objects are displayed changing the attribute list_display on admin. To do that, you're gonna have to make an inheritance of ParanoidAdmin and change this attribute. 1 2 3 4 5 6 7 8 9 10 11 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel class MyAdmin ( ParanoidAdmin ): list_display = ( '__str__' ,) # Django's Default display when list admin . site . register ( MyModel , MyAdmin ) This is how it will look like: If you like the Paranoid's default list display but just want to add some more attributes, you can do the following: 1 2 class MyAdmin ( ParanoidAdmin ): list_display = ( 'name' , 'phone' ,) + ParanoidAdmin . list_display Checkout Official Docs here Customize filter \u00b6 You can customize filter window as you want like remove, add more filter. Add more filter: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel class MyFilter ( ParanoidAdminFilter ): def lookups ( self , request , mode_admin ): # Method to get tuple with all (`search_param`, `name to show`) # to list on filter window return super () . lookups ( request , mode_admin ) + ( ( 'additional' , 'Additional filter' ), # add aditional filters to super() filter ) def queryset ( self , request , queryset ): # Method to handle the querrying and return the QuerySet[] # to be showed on site if self . value () == 'additional' : # filter additional objects pass else : # Not one of our additionals querry return super () . queryset ( request , queryset ) class MyAdmin ( ParanoidAdmin ): list_filter = ( MyFilter ,) # Use our list filter created just above admin . site . register ( MyModel , MyAdmin ) Look at the result: Checkout Official Docs here Remove filter window: Remove filter window is a peace of cake 1 2 3 4 5 6 7 8 9 10 11 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel class MyAdmin ( ParanoidAdmin ): list_filter = () # set list_filter with 0 filter inside admin . site . register ( MyModel , MyAdmin ) And if you also set list_display to be Django's default it will be just like Django's default model page. 1 2 3 4 5 6 7 8 9 10 11 12 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel class MyAdmin ( ParanoidAdmin ): list_display = ( '__str__' ,) # list like django list_filter = () # remove filter window admin . site . register ( MyModel , MyAdmin ) Django's default view:","title":"Admin"},{"location":"django_admin/#django-admin","text":"","title":"Django Admin"},{"location":"django_admin/#register-your-models","text":"To register your model on django admin, is recomended to let ParanoidAdmin handle with admin action. Otherwise you may have some trouble. ParanoidAdmin also include some aditional methods to look more \"paranoid\" on admin page, some functions are: Delete: soft delete instance Permanently delete: hard delete Restore: remode deleted_at date Filter: filter all, only deleted, not deleted On you admin.py register you models like the example below: 1 2 3 4 5 6 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel admin . site . register ( MyModel , ParanoidAdmin ) This will allow ParanoidAdmin to handle with admin actions. Once done that, it should looks something like this:","title":"Register your models"},{"location":"django_admin/#customize-list","text":"You can customize the way objects are displayed changing the attribute list_display on admin. To do that, you're gonna have to make an inheritance of ParanoidAdmin and change this attribute. 1 2 3 4 5 6 7 8 9 10 11 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel class MyAdmin ( ParanoidAdmin ): list_display = ( '__str__' ,) # Django's Default display when list admin . site . register ( MyModel , MyAdmin ) This is how it will look like: If you like the Paranoid's default list display but just want to add some more attributes, you can do the following: 1 2 class MyAdmin ( ParanoidAdmin ): list_display = ( 'name' , 'phone' ,) + ParanoidAdmin . list_display Checkout Official Docs here","title":"Customize list"},{"location":"django_admin/#customize-filter","text":"You can customize filter window as you want like remove, add more filter. Add more filter: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel class MyFilter ( ParanoidAdminFilter ): def lookups ( self , request , mode_admin ): # Method to get tuple with all (`search_param`, `name to show`) # to list on filter window return super () . lookups ( request , mode_admin ) + ( ( 'additional' , 'Additional filter' ), # add aditional filters to super() filter ) def queryset ( self , request , queryset ): # Method to handle the querrying and return the QuerySet[] # to be showed on site if self . value () == 'additional' : # filter additional objects pass else : # Not one of our additionals querry return super () . queryset ( request , queryset ) class MyAdmin ( ParanoidAdmin ): list_filter = ( MyFilter ,) # Use our list filter created just above admin . site . register ( MyModel , MyAdmin ) Look at the result: Checkout Official Docs here Remove filter window: Remove filter window is a peace of cake 1 2 3 4 5 6 7 8 9 10 11 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel class MyAdmin ( ParanoidAdmin ): list_filter = () # set list_filter with 0 filter inside admin . site . register ( MyModel , MyAdmin ) And if you also set list_display to be Django's default it will be just like Django's default model page. 1 2 3 4 5 6 7 8 9 10 11 12 # admin.py from paranoid_model.admin import ParanoidAdmin from .models import MyModel class MyAdmin ( ParanoidAdmin ): list_display = ( '__str__' ,) # list like django list_filter = () # remove filter window admin . site . register ( MyModel , MyAdmin ) Django's default view:","title":"Customize filter"},{"location":"get_started/","text":"Getting Started \u00b6 Install Django Paranoid Model package from pip 1 pip install django-paranoid-model Add paranoid to your INSTALLED_APPS 1 2 3 4 INSTALLED_APPS = [ ... 'paranoid_model' ]","title":"Get Started"},{"location":"get_started/#getting-started","text":"Install Django Paranoid Model package from pip 1 pip install django-paranoid-model Add paranoid to your INSTALLED_APPS 1 2 3 4 INSTALLED_APPS = [ ... 'paranoid_model' ]","title":"Getting Started"},{"location":"instance_manipulate/","text":"Instance Manipulate \u00b6 ParanoidModel has some some differences on default Django methods. Save \u00b6 This method has no difference, it work just like Django's 1 2 my_paranoid_instance = Paranoid () my_paranoid_instance . save () Delete \u00b6 The most important method. This is why pararanoid model exists. When delete() an instance it should not be really deleted from database, but hide from user. The magic is in the attribute deleted_at . When there is no date (deleted_at is None) it means it has not been deleted, but if has a date it means it has been deleted. So when we call delete(), it will set up the current date to delete_at field and save the instance, instead of deleted. Warning The delete works on CASCADE . That means all related objects are going to be soft deleted as well 1 2 3 4 5 6 7 8 9 10 11 12 13 instance = ParanoidModel . objects . create () instance . delete () # instance has the current # date on the field deleted_at but it still saved on database instance . deleted_at is None >> False # but remember that this delete will do the same to every related instances like: person = Person . objects . create ( name = 'My Name' ) for i in range ( 5 ): Phone . objects . create ( phone = '123456789' , owner = person ) person . delete () # this will soft delete person # but will also delete all the 5 phones related to this person delete(hard_delete=True) \u00b6 You can also delete datas from database. If you really wants to delete the instance from databse you can use parameter hard_delete . It calls Django's default method 1 2 3 4 instance = ParanoidModel . objects . create () intance . delete () # will soft delete instance . delete ( hard_delete = True ) # will call django delete, # so it will be deleted from database Danger Be careful using hard_delete . If hard_delete is True, it will call Django's default delete method, so instance will be deleted from database. is_soft_deletd \u00b6 This is a @property that returns a boolean if current instance has been soft deleted or not. Otherwise, it returns if attribute deleted_at is None. It is just a more easy way to check if deleted_at is None instead of use this whole sentence to check. So you can just do the following: 1 2 3 4 5 6 7 8 instance = ParanoidModel . objects . create () instance . is_soft_deleted >> False instance . delete () instance . is_soft_deleted >> True This property is useful it in a code like this: 1 2 3 4 myself = Person . objects . all ( with_deleted = True , name = 'My name' ) . first () if myself . is_soft_deleted : person . restore () Restore \u00b6 Once an instance has been soft deleted, it can be easily undeleted with method restore() 1 2 3 4 5 6 7 8 9 instance = ParanoidModel . objects . create () instance . delete () instance . is_soft_deleted >> True instance . restore () instance . is_soft_deleted >> False","title":"Instance manipulate"},{"location":"instance_manipulate/#instance-manipulate","text":"ParanoidModel has some some differences on default Django methods.","title":"Instance Manipulate"},{"location":"instance_manipulate/#save","text":"This method has no difference, it work just like Django's 1 2 my_paranoid_instance = Paranoid () my_paranoid_instance . save ()","title":"Save"},{"location":"instance_manipulate/#delete","text":"The most important method. This is why pararanoid model exists. When delete() an instance it should not be really deleted from database, but hide from user. The magic is in the attribute deleted_at . When there is no date (deleted_at is None) it means it has not been deleted, but if has a date it means it has been deleted. So when we call delete(), it will set up the current date to delete_at field and save the instance, instead of deleted. Warning The delete works on CASCADE . That means all related objects are going to be soft deleted as well 1 2 3 4 5 6 7 8 9 10 11 12 13 instance = ParanoidModel . objects . create () instance . delete () # instance has the current # date on the field deleted_at but it still saved on database instance . deleted_at is None >> False # but remember that this delete will do the same to every related instances like: person = Person . objects . create ( name = 'My Name' ) for i in range ( 5 ): Phone . objects . create ( phone = '123456789' , owner = person ) person . delete () # this will soft delete person # but will also delete all the 5 phones related to this person","title":"Delete"},{"location":"instance_manipulate/#deletehard_deletetrue","text":"You can also delete datas from database. If you really wants to delete the instance from databse you can use parameter hard_delete . It calls Django's default method 1 2 3 4 instance = ParanoidModel . objects . create () intance . delete () # will soft delete instance . delete ( hard_delete = True ) # will call django delete, # so it will be deleted from database Danger Be careful using hard_delete . If hard_delete is True, it will call Django's default delete method, so instance will be deleted from database.","title":"delete(hard_delete=True)"},{"location":"instance_manipulate/#is_soft_deletd","text":"This is a @property that returns a boolean if current instance has been soft deleted or not. Otherwise, it returns if attribute deleted_at is None. It is just a more easy way to check if deleted_at is None instead of use this whole sentence to check. So you can just do the following: 1 2 3 4 5 6 7 8 instance = ParanoidModel . objects . create () instance . is_soft_deleted >> False instance . delete () instance . is_soft_deleted >> True This property is useful it in a code like this: 1 2 3 4 myself = Person . objects . all ( with_deleted = True , name = 'My name' ) . first () if myself . is_soft_deleted : person . restore ()","title":"is_soft_deletd"},{"location":"instance_manipulate/#restore","text":"Once an instance has been soft deleted, it can be easily undeleted with method restore() 1 2 3 4 5 6 7 8 9 instance = ParanoidModel . objects . create () instance . delete () instance . is_soft_deleted >> True instance . restore () instance . is_soft_deleted >> False","title":"Restore"},{"location":"making_queries/","text":"Making queries \u00b6 In short, the queries are the same as django's queries. The difference is that by default behavior all soft deleted instances are excluded. To make a querry and include the deleted instance just need to give parameter with_deleted to the querry. This is a boolean parameter, so it can be True or False. Info Soft deleted is an instance where the filed deleted_at is not None All \u00b6 1 2 ParanoidModel . objects . all () # returns all the instancnes that hasn't been soft deleted 1 2 ParanoidModel . objects . all ( with_deleted = False ) # this will exclude the soft deleted 1 2 ParanoidModel . objects . all ( with_deleted = True ) # will include the soft deleted As you can see, . all () will return the same instances that all ( with_deleted = False ) On related_name queries When an instance has been soft deleted, the related_querry all () will return with_deleted = True by default. That happens ecause if the instance has been soft deleted it want's to be querried the deleted objects, BUT you can alway use the parameter with_deleted = False and it all soft deleted are excluded. It's something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 person = Person . objects . create ( name = 'person' ) for i in range ( 20 ): phone = Phone . objects . create ( phone = '123' , owner = person ) if i % 2 == 0 : phone . delete () person . phones . all () # will return all not soft deleted person . delete () # will delete all the phones that belongs to person # since person has been deleted, # a related_name querry will work a little different person . phones . all () # will return all and include the soft deleted person . phones . all ( with_deleted = True ) # will return all and include soft deleted person . phones . all ( with_deleted = False ) # will return all not soft deleted Why paranoid does it The explanation why Paranoid Query does it, is because imagine we have a person and we have 2 phones related to that person , and that person has been soft deleted , and by cascade person's phones also soft deleted. Now imagine that in the future, that person wants a report of your datas once saved in database, so when we filter his data, we will need, also, his data deleted. That is why paranoid query will include soft deleted when querring related_name with a soft delete instance. Filter \u00b6 1 2 ParanoidModel . objects . filter ( ** kwargs ) # Will return the filtered instancnes that has not been soft deleted 1 2 ParanoidModel . objects . filter ( with_deleted = False , ** kwargs ) # Will exclude the soft deleted 1 2 ParanoidModel . objects . filter ( with_deleted = True , ** kwargs ) # Will include the soft deleted On related_name queries It works just like .all() querry. chekcou here As you can see, . filter ( ** kwargs ) will return the same instances that filter ( with_deleted = False , ** kwargs ) Deleted_only \u00b6 To filter only deleted you must use deleted_only filter. Thats because filter override querry parameter deleted_at and change it. 1 2 3 4 5 6 7 8 9 10 11 12 13 for i in range ( 20 ): instance = ParanoidModel . objects . create () if i % 2 == 0 : instance . delete () ParanoidModel . objects . deleted_only () # only soft deleted_instance # DON'T DO THAT # # ParanoidModel.objects.filter(deleted_at__isnull=True) # this param 'deleted_at__isnull' is overwritten by querry filter # that's because every param wich starts with 'deleted_at' are removed Failure Do not do that 1 ParanoidModel . objects . filter ( deleted_at__isnull = True ) The param deleted_at__isnull is overwritten by querry filter. That happens because every param wich starts with deleted_at are removed Get \u00b6 1 2 ParanoidModel . objects . get ( ** kwargs ) # will retrun a single instance of the object that matches with the querry Careful with get() method, because it can raise some errors. The possible raises are: model.DoesNotExist : (Django) will be raised if the querry doesn't match to any instance model.MultipleObjectsReturned : (Django) will be raised if more than 1 instances matches with the querry model.SoftDeleted : will be raised if the instance has been soft deleted. You can do the following: 1 2 3 4 5 try : ParanoidModel . objects . get ( pk = 10 ) except ParanoidModel . DoesNotExist : # The querry didn't find any instance with pk = 10 pass or 1 2 3 4 5 6 try : ParanoidModel . objects . get ( pk = 10 ) except ParanoidModel . SoftDeleted : # The querry found an instance, but it has been soft deleted # it means you need to querry with method get_deleted() or get_or_restore() pass But, if you pay attention it doesn't allow you to get an instance that has been soft deleted. Don't worry, no need to cry! get_deleted and get_or_restore will save you! Get_deleted \u00b6 1 2 ParanoidModel . objects . get_deleted ( ** kwargs ) # will retrun a single instance of the object that matches with the querry Careful with get_deleted() method, because it can raise some errors. The possible raises are: model.DoesNotExist : (Django) will be raised if the querry doesn't match to any instance model.MultipleObjectsReturned : (Django) will be raised if more than 1 instances matches with the querry model.IsNotSoftDeleted : will be raised if the instance has not been soft deleted yet. You can do the following: 1 2 3 4 5 try : ParanoidModel . objects . get_deleted ( pk = 10 ) except ParanoidModel . DoesNotExist : # The querry didn't find any instance with pk = 10 pass or 1 2 3 4 5 6 try : ParanoidModel . objects . get_deleted ( pk = 10 ) except ParanoidModel . IsNotSoftDeleted : # The querry found an instance, but it has not been soft deleted yet # it means you need to querry with method get() pass Get_or_restore \u00b6 This method will work just like Django's wiht a thiny difference, it will restore the instance if it has been soft deleted 1 ParanoidModel . objects . get_or_restore ( pk = 10 ) Like all get method, it can raises some exceptions: model.DoesNotExist : (Django) will be raised if the querry doesn't match to any instance model.MultipleObjectsReturned : (Django) will be raised if more than 1 instances matches with the querry 1 2 3 4 5 try : ParanoidModel . objects . get_deleted ( pk = 10 ) except ParanoidModel . DoesNotExist : # The querry didn't find any instance with pk = 10 pass or 1 2 3 4 5 try : ParanoidModel . objects . get_deleted ( name__icontains = 'a' ) except ParanoidModel . MultipleObjectsReturned : # The querry found more than 1 instance pass Restore \u00b6 This method restore all the instances soft deleted int the current querry set. Look at the example bellow 1 2 3 4 5 6 7 8 9 10 11 12 for i in range ( 20 ): ParanoidModel . objects . create () ParanoidModel . objects . all () . count () == 0 >> True ParanoidModel . objects . all ( with_deleted = True ) . restore () ParanoidModel . objects . all () . count () == 0 : >> False ParanoidModel . objects . all () . count () == 20 : >> True","title":"Making queries"},{"location":"making_queries/#making-queries","text":"In short, the queries are the same as django's queries. The difference is that by default behavior all soft deleted instances are excluded. To make a querry and include the deleted instance just need to give parameter with_deleted to the querry. This is a boolean parameter, so it can be True or False. Info Soft deleted is an instance where the filed deleted_at is not None","title":"Making queries"},{"location":"making_queries/#all","text":"1 2 ParanoidModel . objects . all () # returns all the instancnes that hasn't been soft deleted 1 2 ParanoidModel . objects . all ( with_deleted = False ) # this will exclude the soft deleted 1 2 ParanoidModel . objects . all ( with_deleted = True ) # will include the soft deleted As you can see, . all () will return the same instances that all ( with_deleted = False ) On related_name queries When an instance has been soft deleted, the related_querry all () will return with_deleted = True by default. That happens ecause if the instance has been soft deleted it want's to be querried the deleted objects, BUT you can alway use the parameter with_deleted = False and it all soft deleted are excluded. It's something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 person = Person . objects . create ( name = 'person' ) for i in range ( 20 ): phone = Phone . objects . create ( phone = '123' , owner = person ) if i % 2 == 0 : phone . delete () person . phones . all () # will return all not soft deleted person . delete () # will delete all the phones that belongs to person # since person has been deleted, # a related_name querry will work a little different person . phones . all () # will return all and include the soft deleted person . phones . all ( with_deleted = True ) # will return all and include soft deleted person . phones . all ( with_deleted = False ) # will return all not soft deleted Why paranoid does it The explanation why Paranoid Query does it, is because imagine we have a person and we have 2 phones related to that person , and that person has been soft deleted , and by cascade person's phones also soft deleted. Now imagine that in the future, that person wants a report of your datas once saved in database, so when we filter his data, we will need, also, his data deleted. That is why paranoid query will include soft deleted when querring related_name with a soft delete instance.","title":"All"},{"location":"making_queries/#filter","text":"1 2 ParanoidModel . objects . filter ( ** kwargs ) # Will return the filtered instancnes that has not been soft deleted 1 2 ParanoidModel . objects . filter ( with_deleted = False , ** kwargs ) # Will exclude the soft deleted 1 2 ParanoidModel . objects . filter ( with_deleted = True , ** kwargs ) # Will include the soft deleted On related_name queries It works just like .all() querry. chekcou here As you can see, . filter ( ** kwargs ) will return the same instances that filter ( with_deleted = False , ** kwargs )","title":"Filter"},{"location":"making_queries/#deleted_only","text":"To filter only deleted you must use deleted_only filter. Thats because filter override querry parameter deleted_at and change it. 1 2 3 4 5 6 7 8 9 10 11 12 13 for i in range ( 20 ): instance = ParanoidModel . objects . create () if i % 2 == 0 : instance . delete () ParanoidModel . objects . deleted_only () # only soft deleted_instance # DON'T DO THAT # # ParanoidModel.objects.filter(deleted_at__isnull=True) # this param 'deleted_at__isnull' is overwritten by querry filter # that's because every param wich starts with 'deleted_at' are removed Failure Do not do that 1 ParanoidModel . objects . filter ( deleted_at__isnull = True ) The param deleted_at__isnull is overwritten by querry filter. That happens because every param wich starts with deleted_at are removed","title":"Deleted_only"},{"location":"making_queries/#get","text":"1 2 ParanoidModel . objects . get ( ** kwargs ) # will retrun a single instance of the object that matches with the querry Careful with get() method, because it can raise some errors. The possible raises are: model.DoesNotExist : (Django) will be raised if the querry doesn't match to any instance model.MultipleObjectsReturned : (Django) will be raised if more than 1 instances matches with the querry model.SoftDeleted : will be raised if the instance has been soft deleted. You can do the following: 1 2 3 4 5 try : ParanoidModel . objects . get ( pk = 10 ) except ParanoidModel . DoesNotExist : # The querry didn't find any instance with pk = 10 pass or 1 2 3 4 5 6 try : ParanoidModel . objects . get ( pk = 10 ) except ParanoidModel . SoftDeleted : # The querry found an instance, but it has been soft deleted # it means you need to querry with method get_deleted() or get_or_restore() pass But, if you pay attention it doesn't allow you to get an instance that has been soft deleted. Don't worry, no need to cry! get_deleted and get_or_restore will save you!","title":"Get"},{"location":"making_queries/#get_deleted","text":"1 2 ParanoidModel . objects . get_deleted ( ** kwargs ) # will retrun a single instance of the object that matches with the querry Careful with get_deleted() method, because it can raise some errors. The possible raises are: model.DoesNotExist : (Django) will be raised if the querry doesn't match to any instance model.MultipleObjectsReturned : (Django) will be raised if more than 1 instances matches with the querry model.IsNotSoftDeleted : will be raised if the instance has not been soft deleted yet. You can do the following: 1 2 3 4 5 try : ParanoidModel . objects . get_deleted ( pk = 10 ) except ParanoidModel . DoesNotExist : # The querry didn't find any instance with pk = 10 pass or 1 2 3 4 5 6 try : ParanoidModel . objects . get_deleted ( pk = 10 ) except ParanoidModel . IsNotSoftDeleted : # The querry found an instance, but it has not been soft deleted yet # it means you need to querry with method get() pass","title":"Get_deleted"},{"location":"making_queries/#get_or_restore","text":"This method will work just like Django's wiht a thiny difference, it will restore the instance if it has been soft deleted 1 ParanoidModel . objects . get_or_restore ( pk = 10 ) Like all get method, it can raises some exceptions: model.DoesNotExist : (Django) will be raised if the querry doesn't match to any instance model.MultipleObjectsReturned : (Django) will be raised if more than 1 instances matches with the querry 1 2 3 4 5 try : ParanoidModel . objects . get_deleted ( pk = 10 ) except ParanoidModel . DoesNotExist : # The querry didn't find any instance with pk = 10 pass or 1 2 3 4 5 try : ParanoidModel . objects . get_deleted ( name__icontains = 'a' ) except ParanoidModel . MultipleObjectsReturned : # The querry found more than 1 instance pass","title":"Get_or_restore"},{"location":"making_queries/#restore","text":"This method restore all the instances soft deleted int the current querry set. Look at the example bellow 1 2 3 4 5 6 7 8 9 10 11 12 for i in range ( 20 ): ParanoidModel . objects . create () ParanoidModel . objects . all () . count () == 0 >> True ParanoidModel . objects . all ( with_deleted = True ) . restore () ParanoidModel . objects . all () . count () == 0 : >> False ParanoidModel . objects . all () . count () == 20 : >> True","title":"Restore"}]}